<html>
    <head>
	<script   src="https://code.jquery.com/jquery-2.2.4.min.js"   integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44="   crossorigin="anonymous"></script>
	<link rel="stylesheet" type="text/css" href="css/bootstrap.css"/>
	<link rel="stylesheet" type="text/css" href="css/ridge.css"/>
	<script type="text/javascript" src="js/bootstrap.js">
	</script>

	<script type="text/javascript" src="glMatrix-0.9.5.min.js">
	 </script>
	<script id="shader-fs" type="x-shader/x-fragment">
	 precision mediump float;

	 void main(void) {
	     gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
	 }
	</script>
	<script id="shader-vs" type="x-shader/x-vertex">
	 attribute vec3 aVertexPosition;
	 uniform mat4 uMVMatrix;
	 uniform mat4 uPMatrix;

	 void main(void) {
	     gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
	 }
	</script>
	<script type="text/javascript">
	 var gl;
	 function initGL(canvas) {
	     try {
		 gl = canvas.getContext("experimental-webgl");
		 gl.viewportWidth = canvas.width;
		 gl.viewportHeight = canvas.height;
		 console.log("WebGL initialized");
	     } catch (e) {
	     }
	     if (!gl) {
		 alert("Could not initialise WebGL");
	     }
	 }

	 function getShader(gl, id) {
	     var shaderScript = document.getElementById(id);
	     if (!shaderScript) {
		 return null;
	     }

	     var str = "";
	     var k = shaderScript.firstChild;
	     while (k) {
		 if (k.nodeType == 3) {
		     str += k.textContent;
		 }
		 k = k.nextSibling;
	     }
	     
	     var shader;
	     if (shaderScript.type == "x-shader/x-fragment") {
		 shader = gl.createShader(gl.FRAGMENT_SHADER);
	     } else if (shaderScript.type == "x-shader/x-vertex") {
		 shader = gl.createShader(gl.VERTEX_SHADER);
	     } else {
		 alert("could not find shader: ", id);
		 return null;
	     }

	     gl.shaderSource(shader, str);
	     gl.compileShader(shader);

	     if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
		 alert(gl.getShaderInfoLog(shader));
		 return null;
	     }

	     return shader;
	     
	 }

	 var shaderProgram;

	 function initShaders() {
	     var fragmentShader = getShader(gl, "shader-fs");
	     var vertexShader = getShader(gl, "shader-vs");

	     shaderProgram = gl.createProgram();
	     gl.attachShader(shaderProgram, vertexShader);
	     gl.attachShader(shaderProgram, fragmentShader);
	     gl.linkProgram(shaderProgram);

	     if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
		 alert("Could not initialise shaders");
	     }

	     gl.useProgram(shaderProgram);

	     shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
	     gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
	     shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
	     shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
	 }

	 var mvMatrix = mat4.create();
	 var pMatrix = mat4.create();

	 function setMatrixUniforms() {
	     gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
	     gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
	 }

	 var triangleVertexPositionBuffer;
	 var squareVertexPositionBuffer;

	 function initBuffers() {
	     triangleVertexPositionBuffer = gl.createBuffer();
	     gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
	     var vertices = [
		  0.0,  1.0, 0.0,
		 -1.0, -1.0, 0.0,
		 1.0, -1.0, 0.0
	     ];

	     gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices),
			   gl.STATIC_DRAW);
	     triangleVertexPositionBuffer.itemSize = 3;
	     triangleVertexPositionBuffer.numItems = 3;

	     squareVertexPositionBuffer = gl.createBuffer();
	     gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
	     vertices = [
		 1.0, 1.0, 0.0,
		-1.0, 1.0, 0.0,
		 1.0, -1.0, 0.0,
		-1.0, -1.0, 0.0
	     ];

	     gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices),
			   gl.STATIC_DRAW);
	     squareVertexPositionBuffer.itemSize = 3;
	     squareVertexPositionBuffer.numItems = 4;
	 }

	 function drawScene() {
	     gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
	     gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

	     mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
	     mat4.identity(mvMatrix);

	     mat4.translate(mvMatrix, [-1.5, 0.0, -7.0]);

	     gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
	     gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
	     setMatrixUniforms();
	     gl.drawArrays(gl.TRIANGLES, 0, triangleVertexPositionBuffer, triangleVertexPositionBuffer.numItems);

	     mat4.translate(mvMatrix, [3.0, 0.0, 0.0]);
	     gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
	     gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, squareVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
	     setMatrixUniforms();
	     gl.drawArrays(gl.TRIANGLE_STRIP, 0, squareVertexPositionBuffer.numItems);
	 }

	 function webGLStart() {
	     var canvas = document.getElementById("webcanvas");
	     initGL(canvas);
	     initShaders();
	     initBuffers();

	     gl.clearColor(0.0, 0.0, 0.0, 1.0);
	     gl.enable(gl.DEPTH_TEST);

	     drawScene();
	 }

	 window.addEventListener("load", function() {
	     webGLStart();
	 });
	</script>
    </head>
    <body>
	<nav class="navbar">
	    
	</nav>
	<canvas id="webcanvas" width="500" height="500">
	</canvas>
	<div class="jumbotron">
	    <div class="container">
		<h1>Ridge.io</h1>	
	    </div>
	</div>
	<div class="featurette" >
	    <div class="initial container">
		<img src="./assets/dan.jpg" class="img-rounded" height="180px" width="180px"></img>
		<h1>get stuff Dun</h1>	
	    </div>
	</div>
	<div class="featurette">
	    <div class="container">
		<h1>content</h1>
	    </div>
	</div>	
    </body>
</html>
